using IFY.Shimr.CodeGen.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace IFY.Shimr.CodeGen;

internal class AutoShimBuilder
{
    private readonly GeneratorExecutionContext _context;

    public const string CG_NAMESPACE = "IFY.Shimr.Extensions";
    public const string CG_CLASSNAME = "AutogeneratedShims";
    public const string CG_CLASSNAMEFULL = $"{CG_NAMESPACE}.{CG_CLASSNAME}";

    public INamedTypeSymbol AttributeSymbol { get; }

    public AutoShimBuilder(GeneratorExecutionContext context)
    {
        _context = context;

        var attrType = typeof(ShimgenAttribute);
        AttributeSymbol = _context.Compilation.GetTypeByMetadataName(attrType.FullName)!;
    }

    public ShimterfaceModel[] GetInterfaceShims(InterfaceDeclarationSyntax interfaceDeclaration)
    {
        var attrs = interfaceDeclaration.AttributeLists
            .SelectMany(al => al.Attributes)
            .Where(a => a.GetTypeSymbol(_context)?.Equals(AttributeSymbol, SymbolEqualityComparer.Default) == true)
            .ToArray();
        var underlying = attrs.Select(getTypeFromAttribute)
            .Where(t => t != null)
            .Cast<INamedTypeSymbol>().ToArray();
        return underlying.Select(u => ShimterfaceModel.GetOrCreate(interfaceDeclaration.GetTypeSymbol(_context)!).AddShim(u))
            .Select(s => s.Shimterface)
            .Distinct().ToArray();
    }
    private INamedTypeSymbol? getTypeFromAttribute(AttributeSyntax attr) // Expects: [Attr(typeof(T))]
    {
        // TODO: Also support [Attr<T>()]

        var children = attr.ChildNodes().ToArray();
        if (children.Length == 2 && children[1] is AttributeArgumentListSyntax argList
            && argList.Arguments.Count == 1 && argList.Arguments[0].Expression is TypeOfExpressionSyntax tof)
        {
            return tof.Type.GetTypeSymbol(_context);
        }

        return null;
    }

    public void BuildFactoryClass(StringBuilder code)
    {
        code.AppendLine("using System;");
        code.AppendLine($"namespace {CG_NAMESPACE}");
        code.AppendLine("{");
        code.AppendLine("    public static partial class ShimBuilder");
        code.AppendLine("    {");
        
        code.AppendLine("        public static T Create<T>()");
        code.AppendLine("        {");
        code.AppendLine("            return default(T);");
        code.AppendLine("        }");

        code.AppendLine("    }");
        code.AppendLine("}");
    }

    public void BuildExtensionClass(StringBuilder code, ShimModel[] shims)
    {
        code.AppendLine("using System;");
        code.AppendLine($"namespace {CG_NAMESPACE}");
        code.AppendLine("{");
        code.AppendLine("    /// <summary>");
        code.AppendLine("    /// The automatically generated 'Shim' and 'Unshim' extension methods.");
        code.AppendLine("    /// </summary>");
        code.AppendLine($"    public static partial class {CG_CLASSNAME}");
        code.AppendLine("    {");

        // Shim: Underlying -> Interface
        var shimTypes = shims.GroupBy(s => s.UnderlyingFullName).ToArray();
        foreach (var underlyingShims in shimTypes)
        {
            code.AppendLine($"        public static T Shim<T>(this {underlyingShims.Key} inst)");
            code.AppendLine("        {");
            code.AppendLine("            switch (typeof(T))");
            code.AppendLine("            {");
            foreach (var shim in underlyingShims)
            {
                code.AppendLine($"                case Type t when t == typeof({shim.InterfaceFullName}):");
                code.AppendLine($"                    return (T)(object)new {shim.Name}(inst);"); // TODO
            }
            code.AppendLine("            }");
            code.AppendLine("            throw new NotSupportedException();"); // TODO: detail
            code.AppendLine("        }");
        }

        // Unshim: Interface -> Underlying
        shimTypes = shims.GroupBy(s => s.InterfaceFullName).ToArray();
        foreach (var shim in shimTypes)
        {
            code.AppendLine($"        public static object Unshim(this {shim.Key} shim) => ((IShim)shim).Unshim();");
            code.AppendLine($"        public static T Unshim<T>(this {shim.Key} shim) => (T)(object)((IShim)shim).Unshim();");
        }

        code.AppendLine("    }");
        code.AppendLine("}");
    }

    public void BuildShimClass(StringBuilder code, ShimModel shim)
    {
        code.AppendLine("using System;");
        code.AppendLine($"namespace {CG_NAMESPACE}");
        code.AppendLine("{");
        code.AppendLine($"    public static partial class {CG_CLASSNAME}");
        code.AppendLine("    {");
        code.AppendLine($"        protected class {shim.Name} : {shim.InterfaceFullName}, IShim"); // TODO: only visible to Extensions
        code.AppendLine("        {");
        code.AppendLine($"            protected readonly {shim.UnderlyingFullName} _inst;");
        code.AppendLine($"            public {shim.Name}({shim.UnderlyingFullName} inst) => _inst = inst;");
        code.AppendLine("            public object Unshim() => _inst;");

        var members = shim.Shimterface.ResolveShimMembers();
        foreach (var member in members)
        {
            member.GenerateCode(code, shim.UnderlyingType);
        }

        if (!members.OfType<ShimMethod>().Any(m => m.Name == nameof(ToString) && m.ParameterCount == 0))
        {
            code.AppendLine("            public override string ToString() => _inst.ToString();");
        }

        code.AppendLine("        }");
        code.AppendLine("    }");
        code.AppendLine("}");
    }
}
